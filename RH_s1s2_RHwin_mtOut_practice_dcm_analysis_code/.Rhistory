get.add.inf <- function(a, b, n){
# this function convolves the two densities to produce a density reflecting the additive influence
convolve(a, rev(b), type="open")[c(((n/2)+1):(length(a)+(n/2)))]
}
n = 100
densA = get.add.inf(dat$dat[dat$p==.8 & dat$fact == "reward"], dat$dat[dat$p==.8 & dat$fact == "cert"], n )
densB = matrix(data = c(  get.add.inf(dat$dat[dat$p==.8 & dat$fact == "reward"], dat$dat[dat$p==.5 & dat$fact == "cert"]*1.1, n ), # *1.1 is just to shift it a little for viewing
get.add.inf(dat$dat[dat$p==.5 & dat$fact == "reward"], dat$dat[dat$p==.8 & dat$fact == "cert"], n ),
get.add.inf(dat$dat[dat$p==.5 & dat$fact == "reward"], dat$dat[dat$p==.5 & dat$fact == "cert"], n )),
nrow=3, byrow=T )
all.cols = c("#834187", "#834187", "#0c7cba", "#0c7cba")
all.lty = c(1, 2, 1, 2)
plot.denses(densA=densA, densB=densB, x=x,
name="", leg_on = 0, cols=all.cols, ltys=all.lty,
ylims=c(0, max(densA)))
# first make gaussians
get.dens.dat <- function(mu, sd, name, scale){
x    = seq(-1.5, 1.5, length=100)
dat = data.frame(x = rep(x, times=2),
dat = c(dnorm(x, mu, sd), dnorm(x, mu, sd)*scale),
p   = c(rep(.8, times = length(x)), rep(.5, times = length(x))),
fact = rep(name, times = length(x)*2) )
dat
}
sds = 0.3
mu  = 0
scales = c(0.5, 0.5, 0.1)
names = c("reward", "cert", "cert_null")
dat = do.call(rbind, mapply(get.dens.dat, scale = scales, name = names, MoreArgs = list(sd = sds, mu = mu), SIMPLIFY = FALSE))
dat$dat[dat$p==.8 & dat$fact == "cert_null"] = dat$dat[dat$p==.5 & dat$fact == "cert_null"]
# plot case 1, striatum only encodes reward, and not certainty
plot.denses <- function(densA, densB, x, name, leg_on, cols, ltys, ylims){
# if necessary, transfrom densB from a vector to a matrix
if(!any(nrow(densB))) densB = matrix(data=densB, nrow=1)
plot(x, densA, type ="l", lwd=2, main = name, axes=F, xlab="", ylab="", col=cols[1], lty=ltys[1], ylim=ylims)
for(i in 1:nrow(densB)) lines(x, densB[i,], type="l", lwd=2, col=cols[i+1], lty=ltys[i+1])
if (any(leg_on)) legend(x[1], max(densA), col=cols, lty=ltys, legend=c(".8 reward", ".5 reward"), box.lty=0)
}
rew.cols = matrix(data = c(131, 65, 135, 12, 124, 186), nrow=2, byrow=T)
rew.cols = c("#834187", "#0c7cba")
cert.cols = c("#7D7D7D", "#7D7D7D")
rew.lty  = c(1,1)
cert.lty = c(1,2)
x = seq(-1.5, 1.5, length=100)
par(mfrow = c(2,4))
plot.denses(densA=dat$dat[dat$p==.8 & dat$fact == "reward"], densB=dat$dat[dat$p==.5 & dat$fact == "reward"], x=x,
name="reward val", leg_on = 0, cols=rew.cols, ltys=rew.lty,
ylims=c(0, max(dat$dat[dat$p==.8 & dat$fact == "reward"])))
par(xpd = TRUE)
text(x[2], max(dat$dat), "a)", cex=1.5, adj=1)
mtext("+", side=4, cex=1.5)
plot.denses(densA=dat$dat[dat$p==.8 & dat$fact == "cert_null"]*1.3, densB=dat$dat[dat$p==.5 & dat$fact == "cert_null"],             x=x,
name="certainty", leg_on = 0, cols=cert.cols, ltys=cert.lty,
ylims=c(0, max(dat$dat[dat$p==.8 &  dat$fact == "reward"])))
mtext("||", side=4)
# now put together densities for the end result
densA = dat$dat[dat$p==.8 & dat$fact == "reward"]*1.1 # 1.2 is just to scale it a little away from the other
# more or less overlapping line, same with *1.3 in the call to plot.denses above
densB = matrix(data = c( dat$dat[dat$p==.8 & dat$fact == "reward"],
dat$dat[dat$p==.5 & dat$fact == "reward"]*1.1,
dat$dat[dat$p==.5 & dat$fact == "reward"]), nrow=3, byrow=T)
all.cols = c("#834187", "#834187", "#0c7cba", "#0c7cba")
all.lty  = c(1, 2, 1, 2)
plot.denses(densA=densA, densB=densB, x=x,
name="predicted activity", leg_on = 0, cols=all.cols, ltys=all.lty,
ylims=c(0, max(densA)))
plot(NULL ,xaxt='n',yaxt='n',bty='n',ylab='',xlab='', xlim=0:1, ylim=0:1)
legend("topleft", col=c(rew.cols, cert.cols), lty=c(rew.lty, cert.lty), legend=c(".8/.2 reward", ".5/.5 reward", ".8/.2 cert", ".5/.5 cert"), box.lty=0)
plot.denses(densA=dat$dat[dat$p==.8 & dat$fact == "reward"], densB=dat$dat[dat$p==.5 & dat$fact == "reward"], x=x,
name="", leg_on = 0, cols=rew.cols, ltys=rew.lty,
ylims=c(0, max(dat$dat[dat$p==.8 & dat$fact == "reward"])))
par(xpd = TRUE)
text(x[2], max(dat$dat), "b)", cex=1.5, adj=1)
mtext("+", side=4, cex=1.5)
plot.denses(densA=dat$dat[dat$p==.8 & dat$fact == "cert"], densB=dat$dat[dat$p==.5 & dat$fact == "cert"],
x=x, name="", leg_on = 0, cols=cert.cols, ltys=cert.lty,
ylims=c(0, max(dat$dat[dat$p==.8 &  dat$fact == "reward"])))
mtext("||", side=4)
get.add.inf <- function(a, b, n){
# this function convolves the two densities to produce a density reflecting the additive influence
convolve(a, rev(b), type="open")[c(((n/2)+1):(length(a)+(n/2)))]
}
n = 100
densA = get.add.inf(dat$dat[dat$p==.8 & dat$fact == "reward"], dat$dat[dat$p==.8 & dat$fact == "cert"], n )
densB = matrix(data = c(  get.add.inf(dat$dat[dat$p==.8 & dat$fact == "reward"], dat$dat[dat$p==.5 & dat$fact == "cert"]*1.1, n ), # *1.1 is just to shift it a little for viewing
get.add.inf(dat$dat[dat$p==.5 & dat$fact == "reward"], dat$dat[dat$p==.8 & dat$fact == "cert"], n ),
get.add.inf(dat$dat[dat$p==.5 & dat$fact == "reward"], dat$dat[dat$p==.5 & dat$fact == "cert"], n )),
nrow=3, byrow=T )
all.cols = c("#834187", "#834187", "#0c7cba", "#0c7cba")
all.lty = c(1, 2, 1, 2)
plot.denses(densA=densA, densB=densB, x=x,
name="", leg_on = 0, cols=all.cols, ltys=all.lty,
ylims=c(0, max(densA)))
# loading packages for later use
library(dplyr)
rbeta(100, 5, 5, ncp = 0)
rbinom(100, .5)
? rbinom
rm(list=ls())
n = 100
pa = .8
pb = .5
samps = c(1,0)
trls = c(sample(samps, n, replace = TRUE, prob = c(pa, 1-pa),
sample(samps, n, replace = TRUE), prob = c(pb, 1-pb))
)
? samples
? sample
sample(samps, n, replace = TRUE, prob = c(pa, 1-pa)
)
trls = c(sample(samps, n, replace = TRUE, prob = c(pa, 1-pa)),
sample(samps, n, replace = TRUE), prob = c(pb, 1-pb))
trls
e
exp
? pnorm
pnorm(.2)
pnorm(.2)
q = seq(.001, 1, by = .0001)
plot(pnorm(q))
plot(pnorm(q), type = )
plot(pnorm(q), type = "l")
plot(.5*pnorm(q), typre="l")
plot(.5*pnorm(q), type="l")
plot(.5*pnorm(q), type="l", ylim=c(.1, .9))
plot(pnorm(q), type="l", ylim=c(.1, .9))
rm(list=ls())
# get culmulative density of the longest distance over the longest time
cdf_maxDist_overMaxTime = pnorm(threshold_startMax_driftDistance/time_by_driftVar)
##### quick sim of data using LBA
# b = threshold
# A = U[0,A] (A = start max)
# v = drift
# s = standard deviation
time = seq(0.001, 2, by = .001)
drift           = .5
startMax        = .1
threshold       = .8
drift_variance  = 1
# subtract the drift distance (speed x time) from the threshold and the max
# start point *maximal distance travelled?)
threshold_startMax_driftDistance = threshold - startMax - drift*time
# subtract the drift distance (speed x time) from the threshold (shortest distance?)
threshold_driftDistance = threshold - time*drift
# compute time x drift variance (get the longest that time (x) can be?/change in time
# to be multiplied by drift, so variances on distances?)
time_by_driftVar = time * drift_variance
# get culmulative density of the longest distance over the longest time
cdf_maxDist_overMaxTime = pnorm(threshold_startMax_driftDistance/time_by_driftVar)
plot(cdf_maxDist_overMaxTime)
time_by_driftVar
plot(time, cdf_maxDist_overMaxTime)
plot(time, threshold_startMax_driftDistance/startMax * cdf_maxDist_overMaxTime))
plot(time, threshold_startMax_driftDistance/startMax * cdf_maxDist_overMaxTime)
drift           = .5
startMax        = .5
threshold       = .8
drift_variance  = 1
# subtract the drift distance (speed x time) from the threshold and the max
# start point *maximal distance travelled?)
threshold_startMax_driftDistance = threshold - startMax - drift*time
# subtract the drift distance (speed x time) from the threshold (shortest distance?)
threshold_driftDistance = threshold - time*drift
# compute time x drift variance (get the longest that time (x) can be?/change in time
# to be multiplied by drift, so variances on distances?)
time_by_driftVar = time * drift_variance
# get culmulative density of the longest distance over the longest time, for each time point
cdf_maxDist_overMaxTime = pnorm(threshold_startMax_driftDistance/time_by_driftVar)
plot(time, cdf_maxDist_overMaxTime)
plot(time, threshold_startMax_driftDistance/startMax * cdf_maxDist_overMaxTime)
rm(list=ls())
time = seq(0.001, 2, by = .001)
drift           = .9
startMax        = .1
threshold       = .5
drift_variance  = 1
# subtract the drift distance (speed x time) from the threshold and the max
# start point *maximal distance travelled?)
threshold_startMax_driftDistance = threshold - startMax - drift*time
# subtract the drift distance (speed x time) from the threshold (shortest distance?)
threshold_driftDistance = threshold - time*drift
# compute time x drift variance (get the longest that time (x) can be?/change in time
# to be multiplied by drift, so variances on distances?)
time_by_driftVar = time * drift_variance
maxTime = threshold_startMax_driftDistance/startMax * pnorm(threshold_startMax_driftDistance/time_by_driftVar)
# TERM 2: min distance x speed
minTime = threshold_driftDistance/startMax * pnorm(threshold_driftDistance/time_by_driftVar)
# TERM 3: # or how big time is relative to where started # why exponent of the log?
# so you have distance over time (speed), of which you get the density function
# then you take the log of the probability, and convert back onto normal scale with exp, hmm, why?
# but basically, taking time relative to start point, and multiplying by the speed, so getting the
# density function of the distance
maxDistance_dens = time_by_driftVar / startMax * exp(log(dnorm( threshold_startMax_driftDistance/time_by_driftVar, 0, 1 )))
# TERM 4: same but for min distance
minDistance_dens = time_by_driftVar / startMax * exp(log(dnorm( threshold_driftDistance/time_by_driftVar, 0, 1 )))
cdf = 1 + maxTime - minTime + maxDistance_dens - minDistance_dens
plot(time, cdf)
plot(time, maxDistance_dens)
lines(time, minDistance_dens, type = "l", col="red")
lines(time, maxDistance_dens - minDistance_dens, type = "l", col="blue")
plot(times, cdf)
plot(time, cdf)
##### breaking down the pdf function
threshold_startMax_driftDistance_o_timebydriftVar = threshold_startMax_driftDistance/time_by_driftVar
plot(time, threshold_startMax_driftDistance_o_timebydriftVar)
# min
threshold_driftDistance_o_timebydriftVar = threshold_driftDistance/time_by_driftVar
lines(time, threshold_driftDistance_o_timebydriftVar, type="l")
plot(time, threshold_driftDistance_o_timebydriftVar, type="l")
lines(time, threshold_startMax_driftDistance_o_timebydriftVar, type="l", col="red")
# TERM 1 - SPEED x DISTANCE|TIME, THEREFORE WHERE IN TIME
where = drift*pnorm(threshold_startMax_driftDistance)
plot(time, where)
where_max_var = driftVar*dnorm(threshold_startMax_driftDistance_o_timebydriftVar)
where_max_var = drift_variance*dnorm(threshold_startMax_driftDistance_o_timebydriftVar)
plot(time, where_max_var)
# TERM 3
where_min = drift*pnorm(threshold_driftDistance_o_timebydriftVar)
# TERM 4 - as term 2, but min
where_min_var = drift_variance*dnorm(threshold_driftDistance_o_timebydriftVar)
1/0.2
plot(time, (-where_max + where_max_var + where_min - where_min_var))
where_max = drift*pnorm(threshold_startMax_driftDistance_o_timebydriftVar)
# TERM 2 - VARIABILITY ON SPEED
where_max_var = drift_variance*dnorm(threshold_startMax_driftDistance_o_timebydriftVar)
# TERM 3 - as term 1, but min
where_min = drift*pnorm(threshold_driftDistance_o_timebydriftVar)
# TERM 4 - as term 2, but min
where_min_var = drift_variance*dnorm(threshold_driftDistance_o_timebydriftVar)
plot(time, (-where_max + where_max_var + where_min - where_min_var))
plot(time, -where_max)
plot(time, where_max_var)
plot(time, where_min)
plot(time, -where_min_var)
pdf = (1/A)*(-where_max + where_max_var + where_min - where_min_var)
pdf = (1/threshold)*(-where_max + where_max_var + where_min - where_min_var)
plot(time, pdf)
plot(time, -where_min_var)
plot(time, where_min_var)
rm(list=ls())
library(BayesFactor)
dat = read.csv("~/Downloads/HealthyAQstudy.csv", header = T)
bf = correlationBF(dat$AQTotal, dat$AvgSlopes)
? correlationBF
install.packages("BayesFactor")
install.packages("BayesFactor")
bf = correlationBF(dat$AQTotal, dat$AvgSlopes)
library(BayesFactor)
bf = correlationBF(dat$AQTotal, dat$AvgSlopes)
bf
bf_spq = correlationBF(dat$SPQTotal, dat$AvgSlopes)
bf_spq = correlationBF(dat$SPQVision, dat$AvgSlopes)
bf_spq
AQ_samples = posterior(bf, iterations = 10000)
summary(AQ_samples)
plot(AQ_samples[,"rho"])
SPQ_samples = posterior(bf_spq, iterations = 10000)
plot(SPQ_samples[,"rho"])
summary(SPQ_samples)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(psych)
library(nlme)
library(car)
get.b.data <- function(fname){
dat <- read.csv(fname, header = TRUE)
dat$sub = as.factor(dat$sub)
dat$grp = as.factor(dat$grp)
levels(dat$grp) = c("train", "control")
# assign parameter name
dat$con = rep(c("ripl_to_rput", "ripl_to_smfc", "rput_to_ripl", "rput_to_smfc", "smfc_to_ripl", "smfc_to_rput"), times = length(levels(dat$sub)))
dat$con = as.factor(dat$con)
dat
}
fname = "~/Dropbox/QBI/mult-conn/multi-practice-repository/RH_s1s2_RHwin_mtOut_practice_dcm_analysis_outdata/behav_correlations/sub_b_params.csv"
params = get.b.data(fname)
# convert to wideform and save for LBA analysis
params.wide = spread(params, con, b)
write.csv(params.wide, file="single_task_practice_params.csv")
cons.of.int = c("rput_to_smfc", "ripl_to_smfc")
params = params[params$con %in% cons.of.int, ]
params$con = droplevels(params$con)
get.behav.data <- function(fname){
# this function assumes that the behavioural data is stored in the below folder
behav.dat        <- read.csv(fname)
behav.dat$sub    <- as.factor(behav.dat$sub)
behav.dat$Group  <- as.factor(behav.dat$Group)
levels(behav.dat$Group) <- c("train","control")
behav.dat = behav.dat[,c(1:2, 3, 5, 7, 9, 29, 32, 27, 28, 33, 34)]
behav.dat
}
behav.dat = get.behav.data('../s1s2_behavioural_data/final_data_cleaned_250ms_to_3_sdevs_1331_recode.csv')
data = inner_join(params, behav.dat, by=c("sub"))
data = data %>% mutate( pre_sing_total = Pre_VS + Pre_AS,
post_sing_total = Post_VS + Post_AS,
prct_down = ((post_sing_total/pre_sing_total)*100) )
#### basic plot function to plot rts by parameter
draw.scatters <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="con")) +
geom_point() +
facet_wrap(~con) +
geom_smooth(method=lm) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
draw.scatters.grp <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="grp")) +
geom_point() +
facet_wrap(~con) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
get.cors <- function(data, iv, dv, method){
# pass in data frame, iv, dv, and method as tests to get outputs
x = data$b[data$con == iv]
y = data[data$con == iv, dv]
test = cor.test(x, y, method=method)
test
}
with(data, hist(prct_down, breaks = 20))
with(data, hist(b, breaks = 20))
with(data, boxplot(b))
#
draw.scatters.grp(data, "prct_down")
lapply(unique(data$con), get.cors, data = data, dv = "prct_down", method="spearman")
#
draw.scatters.grp(data[data$grp == "train", ], "prct_down")
lapply(unique(data$con), get.cors, data = data[data$grp == "train", ], dv = "prct_down", method="spearman")
#
draw.scatters.grp(data[data$grp == "control", ], "prct_down")
lapply(unique(data$con), get.cors, data = data[data$grp == "control", ], dv = "prct_down", method="spearman")
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(psych)
library(nlme)
library(car)
get.b.data <- function(fname){
dat <- read.csv(fname, header = TRUE)
dat$sub = as.factor(dat$sub)
dat$grp = as.factor(dat$grp)
levels(dat$grp) = c("train", "control")
# assign parameter name
dat$con = rep(c("ripl_to_rput", "ripl_to_smfc", "rput_to_ripl", "rput_to_smfc", "smfc_to_ripl", "smfc_to_rput"), times = length(levels(dat$sub)))
dat$con = as.factor(dat$con)
dat
}
fname = "~/Dropbox/QBI/mult-conn/multi-practice-repository/RH_s1s2_RHwin_mtOut_practice_dcm_analysis_outdata/behav_correlations/sub_b_params.csv"
params = get.b.data(fname)
# convert to wideform and save for LBA analysis
params.wide = spread(params, con, b)
write.csv(params.wide, file="single_task_practice_params.csv")
cons.of.int = c("rput_to_smfc", "ripl_to_smfc", "ripl_to_rput")
params = params[params$con %in% cons.of.int, ]
params$con = droplevels(params$con)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(psych)
library(nlme)
library(car)
get.b.data <- function(fname){
dat <- read.csv(fname, header = TRUE)
dat$sub = as.factor(dat$sub)
dat$grp = as.factor(dat$grp)
levels(dat$grp) = c("train", "control")
# assign parameter name
dat$con = rep(c("ripl_to_rput", "ripl_to_smfc", "rput_to_ripl", "rput_to_smfc", "smfc_to_ripl", "smfc_to_rput"), times = length(levels(dat$sub)))
dat$con = as.factor(dat$con)
dat
}
fname = "~/Dropbox/QBI/mult-conn/multi-practice-repository/RH_s1s2_RHwin_mtOut_practice_dcm_analysis_outdata/behav_correlations/sub_b_params.csv"
params = get.b.data(fname)
# convert to wideform and save for LBA analysis
params.wide = spread(params, con, b)
write.csv(params.wide, file="single_task_practice_params.csv")
cons.of.int = c("rput_to_smfc", "ripl_to_smfc", "ripl_to_rput")
params = params[params$con %in% cons.of.int, ]
params$con = droplevels(params$con)
#### basic plot function to plot rts by parameter
draw.scatters <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="con")) +
geom_point() +
facet_wrap(~con) +
geom_smooth(method=lm) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
draw.scatters.grp <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="grp")) +
geom_point() +
facet_wrap(~con) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
get.cors <- function(data, iv, dv, method){
# pass in data frame, iv, dv, and method as tests to get outputs
x = data$b[data$con == iv]
y = data[data$con == iv, dv]
test = cor.test(x, y, method=method)
test
}
with(data, hist(prct_down, breaks = 20))
setwd("~/Dropbox/QBI/mult-conn/multi-practice-repository/RH_s1s2_RHwin_mtOut_practice_dcm_analysis_code")
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(psych)
library(nlme)
library(car)
get.b.data <- function(fname){
dat <- read.csv(fname, header = TRUE)
dat$sub = as.factor(dat$sub)
dat$grp = as.factor(dat$grp)
levels(dat$grp) = c("train", "control")
# assign parameter name
dat$con = rep(c("ripl_to_rput", "ripl_to_smfc", "rput_to_ripl", "rput_to_smfc", "smfc_to_ripl", "smfc_to_rput"), times = length(levels(dat$sub)))
dat$con = as.factor(dat$con)
dat
}
fname = "~/Dropbox/QBI/mult-conn/multi-practice-repository/RH_s1s2_RHwin_mtOut_practice_dcm_analysis_outdata/behav_correlations/sub_b_params.csv"
params = get.b.data(fname)
# convert to wideform and save for LBA analysis
params.wide = spread(params, con, b)
write.csv(params.wide, file="single_task_practice_params.csv")
cons.of.int = c("rput_to_smfc", "ripl_to_smfc", "ripl_to_rput")
params = params[params$con %in% cons.of.int, ]
params$con = droplevels(params$con)
get.behav.data <- function(fname){
# this function assumes that the behavioural data is stored in the below folder
behav.dat        <- read.csv(fname)
behav.dat$sub    <- as.factor(behav.dat$sub)
behav.dat$Group  <- as.factor(behav.dat$Group)
levels(behav.dat$Group) <- c("train","control")
behav.dat = behav.dat[,c(1:2, 3, 5, 7, 9, 29, 32, 27, 28, 33, 34)]
behav.dat
}
behav.dat = get.behav.data('../s1s2_behavioural_data/final_data_cleaned_250ms_to_3_sdevs_1331_recode.csv')
data = inner_join(params, behav.dat, by=c("sub"))
data = data %>% mutate( pre_sing_total = Pre_VS + Pre_AS,
post_sing_total = Post_VS + Post_AS,
prct_down = ((post_sing_total/pre_sing_total)*100) )
#### basic plot function to plot rts by parameter
draw.scatters <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="con")) +
geom_point() +
facet_wrap(~con) +
geom_smooth(method=lm) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
draw.scatters.grp <- function(data, dv){
# enter the dataframe and the behavioural DV of choice to yield scatter plot of b_param by    dv
scat = ggplot(data, aes_string(x="b", y=dv, col="grp")) +
geom_point() +
facet_wrap(~con) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank())
scat
}
get.cors <- function(data, iv, dv, method){
# pass in data frame, iv, dv, and method as tests to get outputs
x = data$b[data$con == iv]
y = data[data$con == iv, dv]
test = cor.test(x, y, method=method)
test
}
with(data, hist(prct_down, breaks = 20))
with(data, hist(b, breaks = 20))
with(data, boxplot(b))
#
draw.scatters.grp(data, "prct_down")
lapply(unique(data$con), get.cors, data = data, dv = "prct_down", method="spearman")
